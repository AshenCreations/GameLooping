#include "utils.h"

// round a float to nearest int
int round_float2Int(float a)
{
    float offset = 0.5f;
    if(a < 0)
        offset = -0.5f;
    return (int)(a + offset);
}

// return the square of float
float square(float a)
{
    return a * a;
}

Vec2 square(Vec2 a)
{
    a.x *= a.x;
    a.y *= a.y;
    return {a.x, a.y};
}

float cubed(float a)
{
    return a * a * a;
}

// returns the distance from a to b
float check_distance(Vec2 a, Vec2 b)
{
    return sqrtf(square(b.x - a.x) + square(b.y - a.y));
}

// returns vector magnitude from Vec2 input
float Vec2_length(Vec2 vec)
{
    return sqrtf(square(vec.x) + square(vec.y));
}

// remap the value in range i -> equivalent value in range o
float remap_range(float value, float iMin, float iMax, float oMin, float oMax)
{
    return oMin + (oMax - oMin) * ((value - iMin) / (iMax - iMin));
}

//^^^^^^^^^^^^^^^^^^^^^ lerp functions START ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// lerp returns a blend between a and b, based on a fraction t
// inverse lerp returns a fraction t, based on a value between a and b
// remap returns an output generated from a lerp which uses the t generated by an inverse lerp

float lerp(float a, float b, float t)
{
    return (a * (1.0f - t)) + (b * t);
}

u8 lerp(u8 a, u8 b, float t)
{
    return round_float2Int((a * (1.0f - t)) + (b * t));
}

Vec2 lerp(Vec2 a, Vec2 b, float t)
{
    return (a * (1.0f - t)) + (b * t);
}

Color lerp(Color a, Color b, float t)
{
    u8 R = lerp(a.r, b.r, t);
    u8 G = lerp(a.g, b.g, t);
    u8 B = lerp(a.b, b.b, t);

    return {R, G, B};
}

float inverse_lerp(float a, float b, float v)
{
    return (v - a) - (b - a);
}

// inverse lerp for Vec2's. If this solution works then it may work for Vec3's
float inverse_lerp(Vec2 a, Vec2 b, Vec2 value)
{
	Vec2 AB = b - a;
	Vec2 AV = value - a;
	return dot_product(AV, AB) / dot_product(AB, AB);
}

float remap_lerp(float iMin, float iMax, float oMin, float oMax, float value)
{
    float t = inverse_lerp(iMin, iMax, value);
    return lerp(oMin, oMax, t);
}

//^^^^^^^^^^^^^^^^^^^^^ lerp functions END ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// return inner product of 2 Vec2's, one of which must be normalised
float dot_product(Vec2 a, Vec2 b)
{
    return (a.x * b.x) + (a.y * b.y);
}

// returns a Vec2 input as a unit vector
Vec2 unit_Vec2(Vec2 a)
{
    return (a / Vec2_length(a));
}

// return true if point pos is in circle a
bool point_in_circle(Vec2 pos, Circle a)
{
    Vec2 dist = a.pos - pos;
    float distSq = dot_product(dist, dist);
    return distSq < square(a.radius);
}

// return true if target circle a collides with source circle b
bool circle_in_circle(Circle a, Circle b)
{
    Vec2 v = a.pos - b.pos;
    float vSq = dot_product(v, v);
    float radiusSum = a.radius + b.radius;
    return vSq < square(radiusSum);
}

// make 2 floats into a Vec2
Vec2 make_Vec2(float x, float y)
{
    return {x, y};
}

// make 1 value into a Vec2
Vec2 make_Vec2(float val)
{
    return {val, val};
}

Color extract_RGB(SDL_Color iCol)
{
    return {iCol.r, iCol.g, iCol.b};
}

float get_time_ms(void)
{
    return (float)app.time;
}

float get_time_secs(void)
{
    return (float)app.time / 1000.0f;
}

//^^^^^^^^^^^^^^^^^^^^^^^^^ BIT CHECKING ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

int setBit(int x, unsigned char position)
{
    int mask = 1 << (position - 1);
    return x | mask;
}

int clearBit(int x, unsigned char position)
{
    int mask = 1 << (position - 1);
  return x & ~mask;
}

int modifyBit(int x, unsigned char position, bool newState)
{
    int mask = 1 << (position - 1);
    int state = int(newState);  // relies on true = 1 and false = 0
    return (x & ~mask) | (-state & mask);
}

int flipBit(int x, unsigned char position)
{
    int mask = 1 << (position - 1);
    return x ^ mask;
}

bool isBitSet(int x, unsigned char position)
{
    x >>= (position - 1);
    return (x & 1) != 0;
}

//^^^^^^^^^^^^^^^^^^^^^^^^^ BIT CHECKING ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
